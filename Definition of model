class CNNModel(nn.Module):
def __init__(self, input_channels, input_length):
    super(CNNModel, self).__init__()
    self.conv1 = nn.Conv1d(input_channels, 16, kernel_size=3, padding=1)
    self.conv2 = nn.Conv1d(16, 32, kernel_size=3, padding=1)
    self.conv3 = nn.Conv1d(32, 64, kernel_size=3, padding=1)
    self.pool = nn.MaxPool1d(kernel_size=2, stride=2)
    self.fc1 = nn.Linear(64, 64)  
    self.fc2 = nn.Linear(64, 1)
    self.dropout = nn.Dropout(p=0.5)

def forward(self, x):
    x = self.pool(torch.relu(self.conv1(x)))
    x = self.pool(torch.relu(self.conv2(x)))
    x = torch.relu(self.conv3(x))
    x = x.view(x.size(0), -1)  # Flatten for fully connected layers
    x = self.dropout(torch.relu(self.fc1(x)))
    x = torch.sigmoid(self.fc2(x))
    return x

def predict_proba(self, X):
    self.eval()
    with torch.no_grad():
        inputs = torch.tensor(X, dtype=torch.float32).unsqueeze(1)
        outputs = self.forward(inputs)
        return torch.cat((1 - outputs, outputs), dim=1).numpy()
    
feature_columns = ['rank_difference', 'average_rank', 'point_difference', 'score_difference', 'is_stake']
X = matches[feature_columns].fillna(0).values.astype(np.float32)
y = matches['is_won'].astype(float).fillna(0).values.astype(np.float32)
